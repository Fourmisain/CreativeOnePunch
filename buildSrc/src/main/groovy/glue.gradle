import java.nio.charset.StandardCharsets
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

import com.google.gson.GsonBuilder

class GluePluginExtension {
	private Task glueTask
	List<String> targets
	String outputName

	GluePluginExtension(Task glueTask) {
		this.glueTask = glueTask
	}

	void setTargets(List<String> targets) {
		this.targets = targets.asImmutable()

		glueTask.dependsOn.clear()
		glueTask.dependsOn targets.collect {
			":${it}:build"
		}
	}
}

class GluePluginImpl implements Plugin<Project> {
	void apply(Project project) {
		GluePluginExtension extension

		def glueTask = project.task('glue') {
			description 'Glues together all projects into one fat mod jar.'
			onlyIf {
				!project.tasks.findByName('build')?.state?.failure
			}

			// TODO https://docs.gradle.org/current/userguide/more_about_tasks.html
			doNotTrackState("can't be botherered right now")

			doLast {
				Glue glue = Glue.of(project)

				def mergedData = glue.createModData()
				extension.targets.each {
					mergedData.merge(glue.readModData(it))
				}
				glue.writeModJar(mergedData.jar)
			}
		}

		extension = project.extensions.create('glue', GluePluginExtension, glueTask)
		Glue.init(project, extension)
	}
}

class Glue {
	class ModData {
		Map<String, byte[]> jar = [:]
		Map<String, String> modJson = [:]
		Map<String, String> refmap = [:]
		Map<String, String> mixin = [:]

		protected ModData() {}
		protected ModData(String subproject) {
			if (subproject) {
				this.jar = readJarMap(inputFile(subproject))
				this.modJson = Glue.fromJson(jar.get("fabric.mod.json"))
				this.refmap  = Glue.fromJson(jar.get(refmapName()))
				this.mixin   = Glue.fromJson(jar.get(mixinConfigName()))
			}
		}

		void merge(ModData other) {
			mergeInto(jar, other.jar)
			mergeInto(modJson, other.modJson, true)
			mergeInto(refmap, other.refmap, true)
			mergeInto(mixin, other.mixin, true)

			jar.put("fabric.mod.json", Glue.toJson(modJson))
			jar.put(refmapName(),      Glue.toJson(refmap))
			jar.put(mixinConfigName(), Glue.toJson(mixin))
		}
	}

	static GSON = new GsonBuilder().disableHtmlEscaping().setPrettyPrinting().create();

	private static Map<Project, Glue> INSTANCES = [:]
	private Project project
	private GluePluginExtension extension

	private Glue(Project project, GluePluginExtension extension) {
		this.project = project
		this.extension = extension
		INSTANCES.put(project, this)
	}

	static void init(Project project, GluePluginExtension extension) {
		INSTANCES.put(project, new Glue(project, extension))
	}

	static Glue of(Project project) {
		return INSTANCES.get(project)
	}

	ModData createModData() {
		return new ModData()
	}

	ModData readModData(String subproject) {
		return new ModData(subproject);
	}

	void writeModJar(Map<String, byte[]> jar) {
		outputPath().mkdirs()

		try (def out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(outputFile())))) {
			for (entry in jar.entrySet()) {
				def path = entry.key
				def bytes = entry.value

				out.putNextEntry(new ZipEntry(path))
				out.write(bytes)
				out.closeEntry();
			}
		}
	}

	Map<String, byte[]> readJarMap(File file) {
		Map<String, byte[]> jarMap = [:]

		project.zipTree(file).visit {
			if (it.isDirectory()) return

			try (def input = it.open()) {
				jarMap.put(it.getPath(), input.readAllBytes())
			}
		}

		return jarMap
	}

	// TODO shouldn't be hardcoded
	File inputFile(String subprojectName) {
		return project.file("${subprojectName}/build/libs/${project.archives_base_name}-${project.mod_version}.jar")
	}

	String refmapName() {
		return project.archives_base_name + '-refmap.json'
	}

	String mixinConfigName() {
		return project.archives_base_name.toLowerCase() + '.mixins.json'
	}

	File outputPath() {
		return project.file('build/libs')
	}

	File outputFile() {
		return new File(outputPath(), (extension.outputName ?: "${project.archives_base_name}-${project.mod_version}") + ".jar")
	}

	// TODO not needed anymore?
	static Map mergeMixinConfigs(Map map1, Map map2) {
		Map merged = new HashMap(map1)

		def mixins1 = map1.get("mixins") ?: []
		def mixins2 = map2.get("mixins") ?: []

		def s1 = mixins1 as Set
		def s2 = mixins2 as Set

		for (def s : s1)
			if (s2.contains(s))
				throw new Error("mixin merge confict! duplicate ${s}, s1 = ${s1}, s2 = ${s2}")

		def mergeMixins = [mixins1, mixins2].flatten() as String[]
		Arrays.sort(mergeMixins)

		merged.put("mixins", mergeMixins)

		def mergePlugin = null
		for (def plugin : [map1, map2].collect { it.get("plugin") }) {
			if (plugin == null) continue

			if (mergePlugin == null) {
				mergePlugin = plugin
			} else {
				throw new Error("mixin merge confict! plugin1 = ${plugin}, plugin2 = ${mergePlugin}")
			}
		}

		if (mergePlugin != null) {
			merged.put("plugin", mergePlugin);
		}

		return merged;
	}

	static void mergeInto(Map target, Map source, boolean logging = false) {
		source.forEach((k, v) -> {
			def exist = target.get(k)

			if (exist == null) {
				target.put(k, v)
			} else if (v instanceof Map) {
				// merge maps
				if (!exist instanceof Map) throw new Error("mismatched types, new: ${v}, old: ${exist}")

				target.putIfAbsent(k, [:])
				mergeInto(exist, v, logging)
			} else if (v instanceof List) {
				// merge lists (without duplicates)
				if (!exist instanceof List) throw new Error("mismatched types, new: ${v}, old: ${exist}")

				target.put(k, (exist as Set + v as Set) as List)
			} else {
				// overwrite value
				if (logging && !v.equals(exist)) {
					println "overwriting value for ${k}, new: ${v}, old: ${exist}"
				}

				target.put(k, v)
			}
		})
	}

	static Map<String, String> fromJson(byte[] data) {
		if (data == null) return [:]
		def str = new String(data, StandardCharsets.UTF_8)
		return GSON.fromJson(str, Map.class)
	}

	static byte[] toJson(Map<String, String> json) {
		return GSON.toJson(json).getBytes(StandardCharsets.UTF_8)
	}
}

plugins.apply(GluePluginImpl)